// The gas schedule keeps two separate schedules for the gas:
// * The instruction_schedule: This holds the gas for each bytecode instruction.
// * The native_schedule: This holds the gas for used (per-byte operated over) for each native
//   function.
// A couple notes:
// 1. The functions that update the cost table are meant to be public -- the
//    association will send a normal transaction to these functions in order
//    to update any costs, or to add any new costs.
// 2. In the case that e.g. an instruction is deleted from the bytecode,
//    that part of the cost schedule needs to be filled in by either a
//    dummy cost, or by the cost of another instruction (and that
//    instruction must map to that slot).
// 3. The initialization of the module will publish the instruction table
//    to the association address, and will preload the vector with the
//    gas schedule for instructions. The VM will then load this into memory at startup.
module GasSchedule {
    import 0x0.Vector;

    // The gas cost for each instruction is represented using two amounts;
    // one for the cpu, and the other for storage.
    struct Cost {
      cpu: u64,
      storage: u64,
    }

    resource T {
        instruction_schedule: Vector.T<Self.Cost>,
        native_schedule: Vector.T<Self.Cost>,
    }

    // Initialize the table under the association account
    initialize() {
        let instruction_table: Vector.T<Self.Cost>;
        assert(get_txn_sender() == 0xA550C18, 0);
        instruction_table = Vector.empty<Self.Cost>();

        // NB: DO NOT change the order of these pushes to the vector.
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 27, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 28, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 31, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 29, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 10, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 29, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 36, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 52, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 29, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 30, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 41, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 41, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 28, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 45, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 45, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 58, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 58, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 56, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 197, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 73, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 94, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 51, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 65, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 45, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 44, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 41, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 42, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 41, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 45, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 44, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 46, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 43, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 49, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 35, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 48, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 51, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 49, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 46, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 47, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 46, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 39, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 29, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 34, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 32, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 30, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 856, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 929, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 929, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 917, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 774, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 1119, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 29, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 41, storage: 1 }
        );
        Vector.push_back<Self.Cost>(
        	&mut instruction_table,
        	Cost { cpu: 10, storage: 1 }
        );

        move_to_sender<T>(T {
            instruction_schedule: move(instruction_table),
            native_schedule: Vector.empty<Self.Cost>(),
        });
        return;
    }

    public new_cost(cpu: u64, storage: u64): Self.Cost {
      return Cost {cpu: move(cpu), storage: move(storage) };
    }

    // Add a cost to the cost table. Whether the cost is native or not is specified by the
    // `is_instruction_cost` variable that is passed in.
    // Note: This adds the instruction onto the end of the vector.
    public add_cost(is_instruction_cost: bool, cost: Self.Cost) acquires T {
        let gas_schedule: &mut Self.T;
        assert(get_txn_sender() == 0xA550C18, 1);

        gas_schedule = borrow_global_mut<T>(0xA550C18);
        if (move(is_instruction_cost)) {
            Vector.push_back<Self.Cost>(&mut move(gas_schedule).instruction_schedule, move(cost));
        } else {
            Vector.push_back<Self.Cost>(&mut move(gas_schedule).native_schedule, move(cost));
        }
        return;
    }

    // Update the instruction at `index` with new cost `cost`. The table in which this cost should
    // be updated is specified by `is_instruction_cost`.
    public update_schedule(is_instruction_cost: bool, index: u64, cost: Self.Cost) acquires T {
        let gas_schedule: &mut Self.T;
        let gas_table: &mut Vector.T<Self.Cost>;
        let new_cost: &mut Self.Cost;
        let len: u64;
        assert(get_txn_sender() == 0xA550C18, 3);

        gas_schedule = borrow_global_mut<T>(0xA550C18);

        // Grab the appropriate table
        if (move(is_instruction_cost)) {
            gas_table = &mut copy(gas_schedule).instruction_schedule;
        } else {
            gas_table = &mut copy(gas_schedule).native_schedule;
        }

        // Make sure that we aren't over indexing
        len = Vector.length<Self.Cost>(freeze(copy(gas_table)));
        assert(copy(index) < move(len), 0);

        // Update the cost at `index`
        new_cost = Vector.borrow_mut<Self.Cost>(move(gas_table), move(index));
        *copy(new_cost) = move(cost);

        return;
    }

    public has(): bool {
        return exists<T>(0xA550C18);
    }

    public num_entries(): u64 acquires T {
        let t: &Self.T;
        let len: u64;
        t = borrow_global<T>(0xA550C18);
        len = Vector.length<Self.Cost>(&move(t).instruction_schedule);
        return move(len);
    }
}
